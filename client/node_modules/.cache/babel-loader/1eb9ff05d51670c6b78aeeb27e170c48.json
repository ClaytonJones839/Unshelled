{"ast":null,"code":"var _jsxFileName = \"/Users/clay/Desktop/Unshelled/client/src/components/tacos/TacoNew.js\";\nimport React, { Component } from \"react\";\nimport { Mutation } from \"react-apollo\";\nimport TacoCSS from \"./Taco.css\";\nimport gql from \"graphql-tag\";\nimport Queries from \"../../graphql/queries\";\nimport Mutations from \"../../graphql/mutations\"; // import { FETCH_TACOS } from \"../../graphql/queries\";\n\nconst FETCH_TACOS = Queries.FETCH_TACOS;\nconst NEW_TACO = Mutations.NEW_TACO;\n\nclass TacoNew extends Component {\n  constructor(props) {\n    super(props); // debugger\n\n    this.state = {\n      name: \"\",\n      style: \"\",\n      price: 0,\n      description: \"\",\n      restaurantId: this.props.restaurantId,\n      message: \"\"\n    };\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  update(type) {\n    return e => {\n      this.setState({\n        [type]: e.target.value\n      });\n    };\n  }\n\n  handleSubmit(e, newTaco) {\n    e.preventDefault(); // debugger\n\n    let name = this.state.name; // our newTaco function will accept an object with the key of \"variables\" pointing to an object with all our passed in variables.\n\n    newTaco({\n      variables: {\n        name: name,\n        style: this.state.style,\n        price: parseInt(this.state.price),\n        description: this.state.description,\n        restaurantId: this.state.restaurantId\n      }\n    }) // after our mutation has run we want to reset our state and show our user the success message\n    .then(data => {\n      this.setState({\n        message: \"New taco \\\"\".concat(name, \"\\\" created successfully\"),\n        name: \"\",\n        style: \"\",\n        price: 0,\n        description: \"\"\n      });\n    });\n  }\n\n  updateCache(cache, {\n    data: {\n      newTaco\n    }\n  }) {\n    let tacos;\n\n    try {\n      // we'll try to read from our cache but if the query isn't in there no sweat!\n      // We only want to update the data if it's in the cache already - totally fine if the data will\n      // be fetched fresh later\n      tacos = cache.readQuery({\n        query: FETCH_TACOS\n      }); // debugger\n    } catch (err) {\n      // debugger\n      return;\n    } // then our writeQuery will only run IF the cache already has data in it\n\n\n    if (tacos) {\n      let tacoArray = tacos.tacos;\n      cache.writeQuery({\n        query: FETCH_TACOS,\n        data: {\n          tacos: tacoArray.concat(newTaco)\n        }\n      });\n    }\n  }\n\n  render() {\n    // debugger\n    return React.createElement(Mutation, {\n      mutation: NEW_TACO,\n      update: (cache, data) => this.updateCache(cache, data),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 93\n      },\n      __self: this\n    }, (newTaco, {\n      data\n    }) => React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 98\n      },\n      __self: this\n    }, React.createElement(\"form\", {\n      onSubmit: e => this.handleSubmit(e, newTaco),\n      className: \"taco-new-form\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 99\n      },\n      __self: this\n    }, React.createElement(\"input\", {\n      onChange: this.update(\"name\"),\n      value: this.state.name,\n      placeholder: \"Name\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 103\n      },\n      __self: this\n    }), React.createElement(\"input\", {\n      onChange: this.update(\"style\"),\n      value: this.state.style,\n      placeholder: \"Style (Optional)\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 108\n      },\n      __self: this\n    }), React.createElement(\"input\", {\n      type: \"number\",\n      onChange: this.update(\"price\"),\n      value: this.state.price,\n      placeholder: \"0\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 113\n      },\n      __self: this\n    }), React.createElement(\"textarea\", {\n      value: this.state.description,\n      onChange: this.update(\"description\"),\n      placeholder: \"Description\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 119\n      },\n      __self: this\n    }), React.createElement(\"button\", {\n      type: \"submit\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 124\n      },\n      __self: this\n    }, \"Create Taco\")), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 126\n      },\n      __self: this\n    }, this.state.message)));\n  }\n\n}\n\nexport default TacoNew;","map":{"version":3,"sources":["/Users/clay/Desktop/Unshelled/client/src/components/tacos/TacoNew.js"],"names":["React","Component","Mutation","TacoCSS","gql","Queries","Mutations","FETCH_TACOS","NEW_TACO","TacoNew","constructor","props","state","name","style","price","description","restaurantId","message","handleSubmit","bind","update","type","e","setState","target","value","newTaco","preventDefault","variables","parseInt","then","data","updateCache","cache","tacos","readQuery","query","err","tacoArray","writeQuery","concat","render"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport { Mutation } from \"react-apollo\";\nimport TacoCSS from \"./Taco.css\";\nimport gql from \"graphql-tag\";\nimport Queries from \"../../graphql/queries\";\nimport Mutations from \"../../graphql/mutations\";\n// import { FETCH_TACOS } from \"../../graphql/queries\";\nconst { FETCH_TACOS } = Queries;\nconst { NEW_TACO } = Mutations;\n\nclass TacoNew extends Component {\n  constructor(props) {\n    super(props);\n    // debugger\n    this.state = {\n      name: \"\",\n      style: \"\",\n      price: 0,\n      description: \"\",\n      restaurantId: this.props.restaurantId,\n      message: \"\"\n    };\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  update(type) {\n    return e => {\n      this.setState({ [type]: e.target.value });\n    };\n  }\n\n  handleSubmit(e, newTaco) {\n    e.preventDefault();\n    // debugger\n    let name = this.state.name;\n\n\n    // our newTaco function will accept an object with the key of \"variables\" pointing to an object with all our passed in variables.\n    newTaco({\n      variables: {\n        name: name,\n        style: this.state.style,\n        price: parseInt(this.state.price),\n        description: this.state.description,\n        restaurantId: this.state.restaurantId\n      }\n    })\n      // after our mutation has run we want to reset our state and show our user the success message\n      .then(data => {\n        this.setState({\n          message: `New taco \"${name}\" created successfully`,\n          name: \"\",\n          style: \"\",\n          price: 0,\n          description: \"\"\n        });\n      });\n  }\n\n  updateCache(\n    cache,\n    {\n      data: { newTaco }\n    }\n  ) {\n    let tacos;\n    try {\n      // we'll try to read from our cache but if the query isn't in there no sweat!\n      // We only want to update the data if it's in the cache already - totally fine if the data will\n      // be fetched fresh later\n      tacos = cache.readQuery({ query: FETCH_TACOS });\n      // debugger\n    } catch (err) {\n      // debugger\n      return;\n    }\n\n    // then our writeQuery will only run IF the cache already has data in it\n    if (tacos) {\n      let tacoArray = tacos.tacos;\n\n      cache.writeQuery({\n        query: FETCH_TACOS,\n        data: { tacos: tacoArray.concat(newTaco) }\n      });\n    }\n  }\n\n\n  render() {\n    // debugger\n    return (\n      <Mutation\n        mutation={NEW_TACO}\n        update={(cache, data) => this.updateCache(cache, data)}\n      >\n        {(newTaco, { data }) => (\n          <div>\n            <form\n              onSubmit={e => this.handleSubmit(e, newTaco)}\n              className=\"taco-new-form\"\n            >\n              <input\n                onChange={this.update(\"name\")}\n                value={this.state.name}\n                placeholder=\"Name\"\n              />\n              <input\n                onChange={this.update(\"style\")}\n                value={this.state.style}\n                placeholder=\"Style (Optional)\"\n              />\n              <input\n                type=\"number\"\n                onChange={this.update(\"price\")}\n                value={this.state.price}\n                placeholder=\"0\"\n              />\n              <textarea\n                value={this.state.description}\n                onChange={this.update(\"description\")}\n                placeholder=\"Description\"\n              />\n              <button type=\"submit\">Create Taco</button>\n            </form>\n            <p>{this.state.message}</p>\n          </div>\n        )}\n      </Mutation>\n    );\n  }\n\n\n}\n\n\n\n\nexport default TacoNew;\n"]},"metadata":{},"sourceType":"module"}