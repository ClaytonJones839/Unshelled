{"ast":null,"code":"var _jsxFileName = \"/Users/clay/Desktop/Unshelled/client/src/components/restaurants/RestaurantNew.js\";\nimport React, { Component } from \"react\";\nimport { Mutation } from \"react-apollo\";\nimport gql from \"graphql-tag\";\nimport Queries from \"../../graphql/queries\";\nimport Mutations from \"../../graphql/mutations\";\nconst NEW_RESTAURANT = Mutations.NEW_RESTAURANT;\n\nclass RestaurantNew extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: \"\",\n      description: \"\",\n      location: \"\",\n      message: \"\"\n    };\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  update(type) {\n    return e => {\n      this.setState({\n        [type]: e.target.value\n      });\n    };\n  }\n\n  handleSubmit(e, newRestaurant) {\n    e.preventDefault();\n    let name = this.state.name; // our newRestaurant function will accept an object with the key of \"variables\" pointing to an object with all our passed in variables.\n\n    newRestaurant({\n      variables: {\n        name: name,\n        description: this.state.description,\n        location: this.state.location\n      }\n    }) // after our mutation has run we want to reset our state and show our user the success message\n    .then(data => {\n      this.setState({\n        message: \"New restaurant \\\"\".concat(name, \"\\\" created successfully\"),\n        name: \"\",\n        description: \"\",\n        location: \"\"\n      });\n    });\n  }\n\n  updateCache(cache, {\n    data: {\n      newRestaurant\n    }\n  }) {\n    let restaurants;\n\n    try {\n      // we'll try to read from our cache but if the query isn't in there no sweat!\n      // We only want to update the data if it's in the cache already - totally fine if the data will\n      // be fetched fresh later\n      restaurants = cache.readQuery({\n        query: Queries.FETCH_RESTAURANTS\n      });\n    } catch (err) {\n      return;\n    } // then our writeQuery will only run IF the cache already has data in it\n\n\n    if (restaurants) {\n      let restaurantArray = restaurants.restaurants;\n      cache.writeQuery({\n        query: Queries.FETCH_RESTAURANTS,\n        data: {\n          restaurants: restaurantArray.concat(newRestaurant)\n        }\n      });\n    }\n  }\n\n  render() {\n    return React.createElement(Mutation, {\n      mutation: NEW_RESTAURANT,\n      update: (cache, data) => this.updateCache(cache, data),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 82\n      },\n      __self: this\n    }, (newRestaurant, {\n      data\n    }) => React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 87\n      },\n      __self: this\n    }, React.createElement(\"form\", {\n      onSubmit: e => this.handleSubmit(e, newRestaurant),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 88\n      },\n      __self: this\n    }, React.createElement(\"input\", {\n      onChange: this.update(\"name\"),\n      value: this.state.name,\n      placeholder: \"Name\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 89\n      },\n      __self: this\n    }), React.createElement(\"input\", {\n      onChange: this.update(\"location\"),\n      value: this.state.location,\n      placeholder: \"Location\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 94\n      },\n      __self: this\n    }), React.createElement(\"textarea\", {\n      value: this.state.description,\n      onChange: this.update(\"description\"),\n      placeholder: \"Description\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 99\n      },\n      __self: this\n    }), React.createElement(\"button\", {\n      type: \"submit\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 104\n      },\n      __self: this\n    }, \"Create Restaurant\")), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 106\n      },\n      __self: this\n    }, this.state.message)));\n  }\n\n}\n\nexport default RestaurantNew;","map":{"version":3,"sources":["/Users/clay/Desktop/Unshelled/client/src/components/restaurants/RestaurantNew.js"],"names":["React","Component","Mutation","gql","Queries","Mutations","NEW_RESTAURANT","RestaurantNew","constructor","props","state","name","description","location","message","handleSubmit","bind","update","type","e","setState","target","value","newRestaurant","preventDefault","variables","then","data","updateCache","cache","restaurants","readQuery","query","FETCH_RESTAURANTS","err","restaurantArray","writeQuery","concat","render"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport { Mutation } from \"react-apollo\";\nimport gql from \"graphql-tag\";\n\nimport Queries from \"../../graphql/queries\";\n\nimport Mutations from \"../../graphql/mutations\";\n\nconst { NEW_RESTAURANT } = Mutations;\n\nclass RestaurantNew extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      name: \"\",\n      description: \"\",\n      location: \"\",\n      message: \"\"\n    };\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  update(type) {\n    return e => {\n      this.setState({ [type]: e.target.value });\n    };\n  }\n\n  handleSubmit(e, newRestaurant) {\n    e.preventDefault();\n    let name = this.state.name;\n\n    // our newRestaurant function will accept an object with the key of \"variables\" pointing to an object with all our passed in variables.\n    newRestaurant({\n      variables: {\n        name: name,\n        description: this.state.description,\n        location: this.state.location\n      }\n    })\n      // after our mutation has run we want to reset our state and show our user the success message\n      .then(data => {\n        this.setState({\n          message: `New restaurant \"${name}\" created successfully`,\n          name: \"\",\n          description: \"\",\n          location: \"\"\n        });\n      });\n  }\n\n  updateCache(\n    cache,\n    {\n      data: { newRestaurant }\n    }\n  ) {\n    let restaurants;\n    try {\n      // we'll try to read from our cache but if the query isn't in there no sweat!\n      // We only want to update the data if it's in the cache already - totally fine if the data will\n      // be fetched fresh later\n      restaurants = cache.readQuery({ query: Queries.FETCH_RESTAURANTS });\n    } catch (err) {\n      return;\n    }\n\n    // then our writeQuery will only run IF the cache already has data in it\n    if (restaurants) {\n      let restaurantArray = restaurants.restaurants;\n\n      cache.writeQuery({\n        query: Queries.FETCH_RESTAURANTS,\n        data: { restaurants: restaurantArray.concat(newRestaurant) }\n      });\n    }\n  }\n\n  render() {\n    return (\n      <Mutation\n        mutation={NEW_RESTAURANT}\n        update={(cache, data) => this.updateCache(cache, data)}\n      >\n        {(newRestaurant, { data }) => (\n          <div>\n            <form onSubmit={e => this.handleSubmit(e, newRestaurant)}>\n              <input\n                onChange={this.update(\"name\")}\n                value={this.state.name}\n                placeholder=\"Name\"\n              />\n              <input\n                onChange={this.update(\"location\")}\n                value={this.state.location}\n                placeholder=\"Location\"\n              />\n              <textarea\n                value={this.state.description}\n                onChange={this.update(\"description\")}\n                placeholder=\"Description\"\n              />\n              <button type=\"submit\">Create Restaurant</button>\n            </form>\n            <p>{this.state.message}</p>\n          </div>\n        )}\n      </Mutation>\n    );\n  }\n}\n\nexport default RestaurantNew;\n"]},"metadata":{},"sourceType":"module"}