{"ast":null,"code":"var _jsxFileName = \"/Users/clay/Desktop/Unshelled/client/src/components/tacos/TacoNew.js\";\nimport React, { Component } from \"react\";\nimport { Mutation } from \"react-apollo\";\nimport gql from \"graphql-tag\";\nimport Queries from \"../../graphql/queries\";\nimport Mutations from \"../../graphql/mutations\"; // import { FETCH_TACOS } from \"../../graphql/queries\";\n\nconst FETCH_TACOS = Queries.FETCH_TACOS;\nconst NEW_TACO = Mutations.NEW_TACO;\n\nclass TacoNew extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: \"\",\n      style: \"\",\n      price: 0,\n      description: \"\",\n      message: \"\"\n    };\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  update(type) {\n    return e => {\n      this.setState({\n        [type]: e.target.value\n      });\n    };\n  }\n\n  handleSubmit(e, newTaco) {\n    e.preventDefault();\n    debugger;\n    let name = this.state.name; // our newTaco function will accept an object with the key of \"variables\" pointing to an object with all our passed in variables.\n\n    newTaco({\n      variables: {\n        name: name,\n        style: this.state.style,\n        price: parseInt(this.state.price),\n        description: this.state.description\n      }\n    }) // after our mutation has run we want to reset our state and show our user the success message\n    .then(data => {\n      this.setState({\n        message: \"New taco \\\"\".concat(name, \"\\\" created successfully\"),\n        name: \"\",\n        style: \"\",\n        price: 0,\n        description: \"\"\n      });\n    });\n  }\n\n  updateCache(cache, {\n    data: {\n      newTaco\n    }\n  }) {\n    let tacos;\n\n    try {\n      // we'll try to read from our cache but if the query isn't in there no sweat!\n      // We only want to update the data if it's in the cache already - totally fine if the data will\n      // be fetched fresh later\n      tacos = cache.readQuery({\n        query: FETCH_TACOS\n      }); // debugger\n    } catch (err) {\n      // debugger\n      return;\n    } // then our writeQuery will only run IF the cache already has data in it\n\n\n    if (tacos) {\n      let tacoArray = tacos.tacos;\n      cache.writeQuery({\n        query: FETCH_TACOS,\n        data: {\n          tacos: tacoArray.concat(newTaco)\n        }\n      });\n    }\n  }\n\n  render() {\n    // debugger\n    return React.createElement(Mutation, {\n      mutation: NEW_TACO,\n      update: (cache, data) => this.updateCache(cache, data),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 91\n      },\n      __self: this\n    }, (newTaco, {\n      data\n    }) => React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 96\n      },\n      __self: this\n    }, React.createElement(\"form\", {\n      onSubmit: e => this.handleSubmit(e, newTaco),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 97\n      },\n      __self: this\n    }, React.createElement(\"input\", {\n      onChange: this.update(\"name\"),\n      value: this.state.name,\n      placeholder: \"Name\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 98\n      },\n      __self: this\n    }), React.createElement(\"input\", {\n      onChange: this.update(\"style\"),\n      value: this.state.style,\n      placeholder: \"Style (Optional)\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 103\n      },\n      __self: this\n    }), React.createElement(\"input\", {\n      type: \"number\",\n      onChange: this.update(\"price\"),\n      value: this.state.price,\n      placeholder: \"0\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 108\n      },\n      __self: this\n    }), React.createElement(\"textarea\", {\n      value: this.state.description,\n      onChange: this.update(\"description\"),\n      placeholder: \"Description\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 114\n      },\n      __self: this\n    }), React.createElement(\"button\", {\n      type: \"submit\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 119\n      },\n      __self: this\n    }, \"Create Taco\")), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 121\n      },\n      __self: this\n    }, this.state.message)));\n  }\n\n}\n\nexport default TacoNew;","map":{"version":3,"sources":["/Users/clay/Desktop/Unshelled/client/src/components/tacos/TacoNew.js"],"names":["React","Component","Mutation","gql","Queries","Mutations","FETCH_TACOS","NEW_TACO","TacoNew","constructor","props","state","name","style","price","description","message","handleSubmit","bind","update","type","e","setState","target","value","newTaco","preventDefault","variables","parseInt","then","data","updateCache","cache","tacos","readQuery","query","err","tacoArray","writeQuery","concat","render"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport { Mutation } from \"react-apollo\";\nimport gql from \"graphql-tag\";\nimport Queries from \"../../graphql/queries\";\nimport Mutations from \"../../graphql/mutations\";\n// import { FETCH_TACOS } from \"../../graphql/queries\";\nconst { FETCH_TACOS } = Queries;\nconst { NEW_TACO } = Mutations;\n\nclass TacoNew extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      name: \"\",\n      style: \"\",\n      price: 0,\n      description: \"\",\n      message: \"\"\n    };\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  update(type) {\n    return e => {\n      this.setState({ [type]: e.target.value });\n    };\n  }\n\n  handleSubmit(e, newTaco) {\n    e.preventDefault();\n    debugger\n    let name = this.state.name;\n\n  \n\n    // our newTaco function will accept an object with the key of \"variables\" pointing to an object with all our passed in variables.\n    newTaco({\n      variables: {\n        name: name,\n        style: this.state.style,\n        price: parseInt(this.state.price),\n        description: this.state.description\n      }\n    })\n      // after our mutation has run we want to reset our state and show our user the success message\n      .then(data => {\n        this.setState({\n          message: `New taco \"${name}\" created successfully`,\n          name: \"\",\n          style: \"\",\n          price: 0,\n          description: \"\"\n        });\n      });\n  }\n\n  updateCache(\n    cache,\n    {\n      data: { newTaco }\n    }\n  ) {\n    let tacos;\n    try {\n      // we'll try to read from our cache but if the query isn't in there no sweat!\n      // We only want to update the data if it's in the cache already - totally fine if the data will\n      // be fetched fresh later\n      tacos = cache.readQuery({ query: FETCH_TACOS });\n      // debugger\n    } catch (err) {\n      // debugger\n      return;\n    }\n\n    // then our writeQuery will only run IF the cache already has data in it\n    if (tacos) {\n      let tacoArray = tacos.tacos;\n\n      cache.writeQuery({\n        query: FETCH_TACOS,\n        data: { tacos: tacoArray.concat(newTaco) }\n      });\n    }\n  }\n\n\n  render() {\n    // debugger\n    return (\n      <Mutation\n        mutation={NEW_TACO}\n        update={(cache, data) => this.updateCache(cache, data)}\n      >\n        {(newTaco, { data }) => (\n        <div>\n          <form onSubmit={e => this.handleSubmit(e, newTaco)}>\n            <input\n              onChange={this.update(\"name\")}\n              value={this.state.name}\n              placeholder=\"Name\"\n            />\n            <input\n              onChange={this.update(\"style\")}\n              value={this.state.style}\n              placeholder=\"Style (Optional)\"\n            />\n            <input\n              type=\"number\"\n              onChange={this.update(\"price\")}\n              value={this.state.price}\n              placeholder=\"0\"\n            />\n            <textarea\n              value={this.state.description}\n              onChange={this.update(\"description\")}\n              placeholder=\"Description\"\n            />\n            <button type=\"submit\">Create Taco</button>\n          </form>\n          <p>{this.state.message}</p>\n        </div>\n        )}\n      </Mutation>\n    );\n  }\n\n\n}\n\n\n\n\nexport default TacoNew;\n"]},"metadata":{},"sourceType":"module"}