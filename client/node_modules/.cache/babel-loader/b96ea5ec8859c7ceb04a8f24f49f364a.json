{"ast":null,"code":"import _taggedTemplateLiteral from \"/Users/clay/Desktop/Unshelled/client/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\n\nfunction _templateObject8() {\n  const data = _taggedTemplateLiteral([\"\\n    query fetchUser($id: ID!) {\\n      user(_id: $id) {\\n        _id\\n        firstName\\n        lastName\\n        username\\n        email\\n        photo\\n        tacoCheckin {\\n          _id\\n          name\\n          restaurant\\n          description\\n          rating\\n        }\\n      }\\n    }\\n  \"]);\n\n  _templateObject8 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject7() {\n  const data = _taggedTemplateLiteral([\"\\n  {\\n    reviews {\\n      _id\\n      body\\n      rating\\n      restaurant {\\n        _id\\n        name\\n      }\\n    }\\n  }\\n  \"]);\n\n  _templateObject7 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject6() {\n  const data = _taggedTemplateLiteral([\"\\n  query fetchReview($id: ID!) {\\n    review(_id: $id) {\\n      _id\\n      body\\n      rating\\n      restaurant {\\n        _id\\n        name\\n      }\\n    }\\n  }\\n  \"]);\n\n  _templateObject6 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject5() {\n  const data = _taggedTemplateLiteral([\"\\n    query fetchTaco($id: ID!) {\\n      taco(_id: $id) {\\n        _id\\n        name\\n        style\\n        description\\n        rating\\n        price\\n        photo\\n        restaurant {\\n          _id\\n          name\\n          location\\n\\n        }\\n        tacoCheckin {\\n          _id\\n          name\\n          restaurant\\n          description\\n          rating\\n        }\\n      }\\n    }\\n    \"]);\n\n  _templateObject5 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  const data = _taggedTemplateLiteral([\"\\n    query fetchRestaurant($id: ID!) {\\n      restaurant(_id: $id) {\\n        _id\\n        name\\n        description\\n        rating\\n        location\\n        photo\\n        tacos {\\n          _id\\n          name\\n          photo\\n        }\\n        reviews {\\n          _id\\n          body\\n          rating\\n        }\\n      }\\n    }\\n    \"]);\n\n  _templateObject4 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  const data = _taggedTemplateLiteral([\"\\n  {\\n    restaurants {\\n      _id\\n      name\\n      description\\n      location\\n      photo\\n      tacos {\\n        _id\\n        name\\n      }\\n    }\\n  }\\n  \"]);\n\n  _templateObject3 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  const data = _taggedTemplateLiteral([\"\\n    query IsUserLoggedIn {\\n      isLoggedIn @client\\n      id @client\\n      photo @client\\n      firstName @client\\n      lastName @client\\n    }\\n\\n  \"]);\n\n  _templateObject2 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral([\"\\n        {\\n          tacos {\\n            _id\\n            name\\n            description\\n            rating\\n            price\\n            photo\\n            restaurant {\\n              _id\\n              name\\n              description\\n            }\\n          tacoCheckin {\\n            _id\\n            name\\n            restaurant\\n            description\\n            rating\\n          }\\n          \\n            \\n          }\\n        }\\n      \"]);\n\n  _templateObject = function () {\n    return data;\n  };\n\n  return data;\n}\n\nimport gql from \"graphql-tag\";\nexport default {\n  FETCH_TACOS: gql(_templateObject()),\n  // FETCH_TACO_CHECKINS: gql`\n  //     query fetchTacoCheckins($id: ID!) {\n  //       tacoCheckins(_id: $id) {\n  //         _id\n  //         name\n  //         description\n  //         rating\n  //       }\n  //     }\n  // `,\n  IS_LOGGED_IN: gql(_templateObject2()),\n  FETCH_RESTAURANTS: gql(_templateObject3()),\n  FETCH_RESTAURANT: gql(_templateObject4()),\n  FETCH_TACO: gql(_templateObject5()),\n  FETCH_REVIEW: gql(_templateObject6()),\n  FETCH_REVIEWS: gql(_templateObject7()),\n  FETCH_USER: gql(_templateObject8()),\n  // Create customFetch function for handling re-authorization\n  // This customFetch (or any fetch you pass to the link) gets uri and options as arguments. We'll use those when we actually execute a fetch.\n  CUSTOM_FETCH: (uri, options) => {\n    // In our application, the refresh token is stored in a redux store\n    // We create an instance of the state here so we can get the refresh token later in our request\n    let state = store.getState(); // This reference to the refreshingPromise will let us check later on if we are executing getting the refresh token.\n\n    this.refreshingPromise = null; // Create initial fetch, this is what would normally be executed in the link without the override\n\n    var initialRequest = fetch(uri, options); // The apolloHttpLink expects that whatever fetch function is used, it returns a promise.\n    // Here we return the initialRequest promise\n\n    return initialRequest.then(response => {\n      return response.json();\n    }).then(json => {\n      // We should now have the JSON from the response of initialRequest\n      // We check that we do and look for errors from the GraphQL server\n      // If it has the error 'User is not logged in' (that's our implementation of a 401) we execute the next steps in the re-auth flow\n      if (json && json.errors && json.errors[0] && json.errors[0].message === 'User is not logged in.') {\n        if (!this.refreshingPromise) {\n          // Grab the refresh token from the store\n          var refresh_token = state.account.loginData.refresh_token; // Grab the client_id from our config\n\n          var client_id = Config.REACT_APP_CLIENT_ID; // Create the address to grab a new token from\n          // This endpoint may vary based on your Oauth server\n\n          var address = Config.REACT_APP_SERVER_ADDRESS + '/o/token/?grant_type=refresh_token&refresh_token=' + refresh_token + '&client_id=' + client_id; // Execute the re-authorization request and set the promise returned to this.refreshingPromise\n\n          this.refreshingPromise = fetch(address, {\n            method: 'POST'\n          }).then(refresh_token_repsonse => {\n            if (refresh_token_repsonse.ok) {\n              return refresh_token_repsonse.json().then(refreshJSON => {\n                // Save the new refresh token to your store or wherever you are keeping it\n                // saveRefreshToken(refreshJSON.refresh_token)\n                // Return the new access token as a result of the promise\n                return refreshJSON.access_token;\n              });\n            } else {// If the re-authorization request fails, handle it here\n              // You can log user out, or display some sort of session has ended alert\n              // logUserOut()\n            }\n          });\n        }\n\n        return this.refreshingPromise.then(newAccessToken => {\n          // Now that the refreshing promise has been executed, set it to null\n          this.refreshingPromise = null; // Set the authorization header on the original options parameter to the new access token we got\n\n          options.headers.authorization = \"Bearer \".concat(newAccessToken); // Return the promise from the new fetch (which should now have used an active access token)\n          // If the initialRequest had errors, this fetch that is returned below is the final result.\n\n          return fetch(uri, options);\n        });\n      } // If there were no errors in the initialRequest, we need to repackage the promise and return it as the final result.\n\n\n      var result = {};\n      result.ok = true;\n\n      result.json = () => new Promise(function (resolve, reject) {\n        resolve(json);\n      });\n\n      return result;\n    });\n  }\n};","map":{"version":3,"sources":["/Users/clay/Desktop/Unshelled/client/src/graphql/queries.js"],"names":["gql","FETCH_TACOS","IS_LOGGED_IN","FETCH_RESTAURANTS","FETCH_RESTAURANT","FETCH_TACO","FETCH_REVIEW","FETCH_REVIEWS","FETCH_USER","CUSTOM_FETCH","uri","options","state","store","getState","refreshingPromise","initialRequest","fetch","then","response","json","errors","message","refresh_token","account","loginData","client_id","Config","REACT_APP_CLIENT_ID","address","REACT_APP_SERVER_ADDRESS","method","refresh_token_repsonse","ok","refreshJSON","access_token","newAccessToken","headers","authorization","result","Promise","resolve","reject"],"mappings":"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","sourcesContent":["import gql from \"graphql-tag\";\n\n\nexport default {\n  FETCH_TACOS: gql`\n        {\n          tacos {\n            _id\n            name\n            description\n            rating\n            price\n            photo\n            restaurant {\n              _id\n              name\n              description\n            }\n          tacoCheckin {\n            _id\n            name\n            restaurant\n            description\n            rating\n          }\n          \n            \n          }\n        }\n      `,\n  \n  // FETCH_TACO_CHECKINS: gql`\n    \n  //     query fetchTacoCheckins($id: ID!) {\n  //       tacoCheckins(_id: $id) {\n  //         _id\n  //         name\n  //         description\n  //         rating\n  //       }\n  //     }\n    \n  // `,\n\n  IS_LOGGED_IN: gql`\n    query IsUserLoggedIn {\n      isLoggedIn @client\n      id @client\n      photo @client\n      firstName @client\n      lastName @client\n    }\n\n  `,\n\n FETCH_RESTAURANTS: gql`\n  {\n    restaurants {\n      _id\n      name\n      description\n      location\n      photo\n      tacos {\n        _id\n        name\n      }\n    }\n  }\n  `,\n\n  FETCH_RESTAURANT: gql`\n    query fetchRestaurant($id: ID!) {\n      restaurant(_id: $id) {\n        _id\n        name\n        description\n        rating\n        location\n        photo\n        tacos {\n          _id\n          name\n          photo\n        }\n        reviews {\n          _id\n          body\n          rating\n        }\n      }\n    }\n    `,\n  \n  FETCH_TACO: gql`\n    query fetchTaco($id: ID!) {\n      taco(_id: $id) {\n        _id\n        name\n        style\n        description\n        rating\n        price\n        photo\n        restaurant {\n          _id\n          name\n          location\n\n        }\n        tacoCheckin {\n          _id\n          name\n          restaurant\n          description\n          rating\n        }\n      }\n    }\n    `,\n\n  FETCH_REVIEW: gql`\n  query fetchReview($id: ID!) {\n    review(_id: $id) {\n      _id\n      body\n      rating\n      restaurant {\n        _id\n        name\n      }\n    }\n  }\n  `,\n\n  FETCH_REVIEWS: gql`\n  {\n    reviews {\n      _id\n      body\n      rating\n      restaurant {\n        _id\n        name\n      }\n    }\n  }\n  `,\n\n  FETCH_USER: gql`\n    query fetchUser($id: ID!) {\n      user(_id: $id) {\n        _id\n        firstName\n        lastName\n        username\n        email\n        photo\n        tacoCheckin {\n          _id\n          name\n          restaurant\n          description\n          rating\n        }\n      }\n    }\n  `,\n  // Create customFetch function for handling re-authorization\n  // This customFetch (or any fetch you pass to the link) gets uri and options as arguments. We'll use those when we actually execute a fetch.\n  CUSTOM_FETCH: (uri, options) => {\n\n    // In our application, the refresh token is stored in a redux store\n    // We create an instance of the state here so we can get the refresh token later in our request\n    let state = store.getState()\n\n    // This reference to the refreshingPromise will let us check later on if we are executing getting the refresh token.\n    this.refreshingPromise = null;\n\n    // Create initial fetch, this is what would normally be executed in the link without the override\n    var initialRequest = fetch(uri, options)\n\n    // The apolloHttpLink expects that whatever fetch function is used, it returns a promise.\n    // Here we return the initialRequest promise\n    return initialRequest.then((response) => {\n      return (response.json())\n    }).then((json) => {\n      // We should now have the JSON from the response of initialRequest\n      // We check that we do and look for errors from the GraphQL server\n      // If it has the error 'User is not logged in' (that's our implementation of a 401) we execute the next steps in the re-auth flow\n      if (json && json.errors && json.errors[0] && json.errors[0].message === 'User is not logged in.') {\n        if (!this.refreshingPromise) {\n\n          // Grab the refresh token from the store\n          var refresh_token = state.account.loginData.refresh_token\n          // Grab the client_id from our config\n          var client_id = Config.REACT_APP_CLIENT_ID\n          // Create the address to grab a new token from\n          // This endpoint may vary based on your Oauth server\n          var address = Config.REACT_APP_SERVER_ADDRESS + '/o/token/?grant_type=refresh_token&refresh_token=' + refresh_token + '&client_id=' + client_id\n\n          // Execute the re-authorization request and set the promise returned to this.refreshingPromise\n          this.refreshingPromise = fetch(address, { method: 'POST' })\n            .then((refresh_token_repsonse) => {\n              if (refresh_token_repsonse.ok) {\n                return refresh_token_repsonse.json().then((refreshJSON) => {\n                  // Save the new refresh token to your store or wherever you are keeping it\n                  // saveRefreshToken(refreshJSON.refresh_token)\n\n                  // Return the new access token as a result of the promise\n                  return refreshJSON.access_token\n                })\n              } else {\n                // If the re-authorization request fails, handle it here\n                // You can log user out, or display some sort of session has ended alert\n                // logUserOut()\n              }\n            })\n        }\n        return this.refreshingPromise.then((newAccessToken) => {\n          // Now that the refreshing promise has been executed, set it to null\n          this.refreshingPromise = null;\n\n          // Set the authorization header on the original options parameter to the new access token we got\n          options.headers.authorization = `Bearer ${newAccessToken}`\n          // Return the promise from the new fetch (which should now have used an active access token)\n          // If the initialRequest had errors, this fetch that is returned below is the final result.\n          return fetch(uri, options);\n        })\n      }\n      // If there were no errors in the initialRequest, we need to repackage the promise and return it as the final result.\n      var result = {}\n      result.ok = true\n      result.json = () => new Promise(function (resolve, reject) {\n        resolve(json);\n      })\n      return result\n    })\n  }\n  \n}\n\n"]},"metadata":{},"sourceType":"module"}